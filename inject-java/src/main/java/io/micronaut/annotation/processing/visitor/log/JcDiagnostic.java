package io.micronaut.annotation.processing.visitor.log;

import java.util.EnumSet;
import java.util.Locale;
import java.util.Set;

import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;

import com.sun.tools.javac.util.DefinedBy;

import static io.micronaut.annotation.processing.visitor.log.JcDiagnostic.DiagnosticType.ERROR;
import static io.micronaut.annotation.processing.visitor.log.JcDiagnostic.DiagnosticType.NOTE;
import static io.micronaut.annotation.processing.visitor.log.JcDiagnostic.DiagnosticType.WARNING;

/**
 * An abstraction of a diagnostic message generated by the compiler.
 */
class JcDiagnostic implements Diagnostic<JavaFileObject> {

    private final DiagnosticSource source;
    private final int position;
    private final String msg;
    private final Set<JcDiagnostic.DiagnosticFlag> flags;
    private final DiagnosticType type;
    /**
     * source line position (set lazily)
     */
    private JcDiagnostic.SourcePosition sourcePosition;
    private DiagnosticFormatter<JcDiagnostic> defaultFormatter;

    /**
     * Create a diagnostic object.
     *
     * @param formatter the formatter to use for the diagnostic
     * @param msg the diagnostic message
     * @param source the name of the source file, or null if none.
     * @param pos the character offset within the source file, if given.
     */
    protected JcDiagnostic(DiagnosticFormatter<JcDiagnostic> formatter,
                           DiagnosticType type,
                           String msg,
                           Set<JcDiagnostic.DiagnosticFlag> flags,
                           DiagnosticSource source,
                           int pos) {
        if (source == null && pos >= 0) {
            throw new IllegalArgumentException();
        }

        this.type = type;
        defaultFormatter = formatter;
        this.msg = msg;
        this.flags = flags;
        this.source = source;
        position = pos;
    }

    /**
     * A factory for creating diagnostic objects.
     */
    public static class Factory {

        static Factory instance;

        /**
         * Get the Factory instance for this context.
         */
        public static JcDiagnostic.Factory instance() {
            if (instance == null) {
                instance = new JcDiagnostic.Factory();
            }
            return instance;
        }

        DiagnosticFormatter<JcDiagnostic> formatter;
        final String prefix;
        final Set<JcDiagnostic.DiagnosticFlag> defaultErrorFlags;

        /**
         * Create a new diagnostic factory.
         */
        protected Factory() {
            this("compiler");
        }

        /**
         * Create a new diagnostic factory.
         */
        public Factory(String prefix) {
            this.prefix = prefix;
            formatter = new BasicDiagnosticFormatter();
            defaultErrorFlags = EnumSet.of(JcDiagnostic.DiagnosticFlag.MANDATORY);
        }

        /**
         * Create an error diagnostic
         *
         * @param source The source of the compilation unit, if any, in which to report the error.
         * @param pos The source position at which to report the error.
         * @param msg The error message.
         */
        public JcDiagnostic error(JcDiagnostic.DiagnosticFlag flag, DiagnosticSource source, int pos, String msg) {
            JcDiagnostic diag = create(EnumSet.copyOf(defaultErrorFlags), source, pos, ERROR, msg);
            if (flag != null) {
                diag.setFlag(flag);
            }
            return diag;
        }

        /**
         * Create a warning diagnostic.
         *
         * @param source The source of the compilation unit, if any, in which to report the warning.
         * @param pos The source position at which to report the warning.
         * @param msg The key for the localized warning message.
         */
        public JcDiagnostic warning(DiagnosticSource source, int pos, String msg) {
            return create(EnumSet.noneOf(JcDiagnostic.DiagnosticFlag.class), source, pos, WARNING, msg);
        }

        /**
         * Create a note diagnostic.
         *
         * @param source The source of the compilation unit, if any, in which to report the note.
         * @param pos The source position at which to report the note.
         * @param msg The key for the localized note message.
         */
        public JcDiagnostic note(DiagnosticSource source, int pos, String msg) {
            return create(EnumSet.noneOf(JcDiagnostic.DiagnosticFlag.class), source, pos, NOTE, msg);
        }

        /**
         * Create a new diagnostic with given key.
         *
         * @param flags The set of flags for the diagnostic
         * @param source The source of the compilation unit, if any, in which to report the message.
         * @param pos The source position at which to report the message.
         * @param msg The message
         */
        public JcDiagnostic create(Set<JcDiagnostic.DiagnosticFlag> flags, DiagnosticSource source, int pos, DiagnosticType type, String msg) {
            return new JcDiagnostic(formatter, type, msg, flags, source, pos);
        }
    }

    /**
     * A DiagnosticType defines the type of the diagnostic.
     **/
    public enum DiagnosticType {
        /**
         * A note: similar to, but less serious than, a warning.
         */
        NOTE("note"),
        /**
         * A warning.
         */
        WARNING("warn"),
        /**
         * An error.
         */
        ERROR("err");

        final String key;

        /**
         * Create a DiagnosticType.
         *
         * @param key A string used to create the resource key for the diagnostic.
         */
        DiagnosticType(String key) {
            this.key = key;
        }
    }

    /**
     * A DiagnosticPosition provides information about the positions in a file
     * that gave rise to a diagnostic. It always defines a "preferred" position
     * that most accurately defines the location of the diagnostic, it may also
     * provide a related tree node that spans that location.
     */
    public interface DiagnosticPosition {

        /**
         * If there is a tree node, get the start position of the tree node.
         * Otherwise, just returns the same as getPreferredPosition().
         */
        int getStartPosition();

        /**
         * Get the position within the file that most accurately defines the
         * location for the diagnostic.
         */
        int getPreferredPosition();
    }

    public enum DiagnosticFlag {
        MANDATORY,
    }

    /**
     * This class is used to defer the line/column position fetch logic after diagnostic construction.
     */
    class SourcePosition {

        private final int line;
        private final int column;

        SourcePosition() {
            int n = position < 0 ? Log.NOPOS : position;
            if (n == Log.NOPOS || source == null) {
                line = column = -1;
            } else {
                line = source.getLineNumber(n);
                column = source.getColumnNumber(n, true);
            }
        }

        public int getLineNumber() {
            return line;
        }

        public int getColumnNumber() {
            return column;
        }
    }

    /**
     * A diagnostic key object encapsulates basic properties of a diagnostic, such as the resource key,
     * the arguments and the kind associated with the diagnostic object. Diagnostic keys can be either
     * created programmatically (by using the supplied factory method) or obtained through build-time
     * generated factory methods.
     */
    public static abstract class DiagnosticInfo {

        /**
         * The diagnostic kind (i.e. error).
         */
        JcDiagnostic.DiagnosticType type;

        /**
         * The diagnostic prefix (i.e. 'javac'); used to compute full resource key.
         */
        String prefix;

        /**
         * The diagnostic arguments.
         */
        Object[] args;

        private DiagnosticInfo(JcDiagnostic.DiagnosticType type, String prefix) {
            this.type = type;
            this.prefix = prefix;
        }

        /**
         * Compute the resource key.
         */
        public String key() {
            return prefix + "." + type.key;
        }
    }

    /**
     * Class representing error diagnostic keys.
     */
    public static final class Error extends JcDiagnostic.DiagnosticInfo {

        public Error(String prefix) {
            super(ERROR, prefix);
        }
    }

    /**
     * Class representing warning diagnostic keys.
     */
    public static final class Warning extends JcDiagnostic.DiagnosticInfo {

        public Warning(String prefix) {
            super(WARNING, prefix);
        }
    }

    /**
     * Class representing note diagnostic keys.
     */
    public static final class Note extends JcDiagnostic.DiagnosticInfo {

        public Note(String prefix) {
            super(NOTE, prefix);
        }
    }

    /**
     * Get the type of this diagnostic.
     *
     * @return the type of this diagnostic
     */
    public JcDiagnostic.DiagnosticType getType() {
        return type;
    }

    /**
     * Get the subdiagnostic list
     *
     * @return subdiagnostic list
     */
    public AnnList<JcDiagnostic> getSubdiagnostics() {
        return AnnList.nil();
    }

    /**
     * Check whether or not this diagnostic is required to be shown.
     *
     * @return true if this diagnostic is required to be shown.
     */
    public boolean isMandatory() {
        return flags.contains(JcDiagnostic.DiagnosticFlag.MANDATORY);
    }

    /**
     * Get the name of the source file referred to by this diagnostic.
     *
     * @return the name of the source referred to with this diagnostic, or null if none
     */
    @Override
    @DefinedBy(DefinedBy.Api.COMPILER)
    public JavaFileObject getSource() {
        if (source == null) {
            return null;
        } else {
            return source.getFile();
        }
    }

    /**
     * Get the source referred to by this diagnostic.
     *
     * @return the source referred to with this diagnostic, or null if none
     */
    public DiagnosticSource getDiagnosticSource() {
        return source;
    }

    @Override
    @DefinedBy(DefinedBy.Api.COMPILER)
    public long getStartPosition() {
        return position;
    }

    @Override
    @DefinedBy(DefinedBy.Api.COMPILER)
    public long getPosition() {
        return position;
    }

    @Override
    @DefinedBy(DefinedBy.Api.COMPILER)
    public long getEndPosition() {
        return Log.NOPOS;
    }

    /**
     * Get the line number within the source referred to by this diagnostic.
     *
     * @return the line number within the source referred to by this diagnostic
     */
    @Override
    @DefinedBy(DefinedBy.Api.COMPILER)
    public long getLineNumber() {
        if (sourcePosition == null) {
            sourcePosition = new JcDiagnostic.SourcePosition();
        }
        return sourcePosition.getLineNumber();
    }

    /**
     * Get the column number within the line of source referred to by this diagnostic.
     *
     * @return the column number within the line of source referred to by this diagnostic
     */
    @Override
    @DefinedBy(DefinedBy.Api.COMPILER)
    public long getColumnNumber() {
        if (sourcePosition == null) {
            sourcePosition = new JcDiagnostic.SourcePosition();
        }
        return sourcePosition.getColumnNumber();
    }

    /**
     * Get the prefix string associated with this type of diagnostic.
     *
     * @return the prefix string associated with this type of diagnostic
     */
    public String getPrefix() {
        return getPrefix(type);
    }

    /**
     * Get the prefix string associated with a particular type of diagnostic.
     *
     * @return the prefix string associated with a particular type of diagnostic
     */
    public String getPrefix(JcDiagnostic.DiagnosticType dt) {
        return defaultFormatter.formatKind(this);
    }

    /**
     * Return the standard presentation of this diagnostic.
     */
    @Override
    public String toString() {
        return defaultFormatter.format(this);
    }

    @Override
    @DefinedBy(DefinedBy.Api.COMPILER)
    public Diagnostic.Kind getKind() {
        return switch (type) {
            case NOTE -> Kind.NOTE;
            case WARNING -> flags.contains(DiagnosticFlag.MANDATORY)
                ? Kind.MANDATORY_WARNING
                : Kind.WARNING;
            case ERROR -> Kind.ERROR;
            default -> Kind.OTHER;
        };
    }

    @Override
    @DefinedBy(DefinedBy.Api.COMPILER)
    public String getCode() {
        return msg;
    }

    @Override
    @DefinedBy(DefinedBy.Api.COMPILER)
    public String getMessage(Locale locale) {
        return defaultFormatter.formatMessage(this);
    }

    public void setFlag(JcDiagnostic.DiagnosticFlag flag) {
        flags.add(flag);
    }

    public boolean isFlagSet(JcDiagnostic.DiagnosticFlag flag) {
        return flags.contains(flag);
    }
}
